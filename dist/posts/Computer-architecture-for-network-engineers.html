<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer architecture for network engineers</title>
    <meta name="description" content="">
    <meta name="author" content="Hrishikesh Barman">

    <link href="/assets/main.css" rel="stylesheet">

  <script>
  window.blogInfo = {
          pageType: 'post',
          postId: 18,
          comment_system: "github"
  };
  </script>

  </head>

  <body class="">
<nav class="nav">
  <div class="nav-left"></div>
  <div class="nav-center">
  <a class="nav-item title is-5" href="/">
    geekodour's blog
  </a>
  </div>
  <span id="nav-toggle" class="nav-toggle">
  <span></span>
  <span></span>
  <span></span>
  </span>
  <div id="nav-menu" class="nav-right nav-menu">
  <a class="nav-item" href="">projects</a>
  <a class="nav-item" href="">favorites</a>
  <a class="nav-item" href="">contact</a>
  </div>
</nav>

      <div class="container">
  <div class="columns">
          <div class="column">
            <div class="section">
<div class="">
  <ul>
  </ul>
</div>
            </div>
          </div>
          <div class="column is-half">
<div class="section">
  <div class="container">
    <div class="content">
      <h1>Computer architecture for network engineers</h1>
      <p><em>This is a rough idea for a talk/tutorial. Critique welcome :).</em></p>
<p>Suppose you are a network engineer and you want to understand how modern x86 CPUs work under the hood. <em>Cache-misses, out-of-order execution, pipelined execution</em>, etc. One approach is to read a big heavy book like <a href="https://www.amazon.com/Computer-Architecture-Fifth-Quantitative-Approach/dp/012383872X">Hennessy and Patterson</a>. However, there is also a short-cut.</p>
<p>CPUs are basically networks these days (#15) and their mechanisms all have direct analogues in TCP. In fact, if you have spent time troubleshooting TCP performance problems in wireshark it&#39;s entirely likely that you have a more visceral intuition for CPU performance that most software people do.</p>
<p>Here is why CPUs are basically equivalent to TCP senders:</p>
<table>
<thead>
<tr>
<th>TCP</th>
<th>CPU</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP <em>sends</em> a stream of <em>packets</em>.</td>
<td>CPU <em>issues</em> a stream of <em>instructions</em>.</td>
</tr>
<tr>
<td>TCP packets are eventually <em>acknowledged</em>.</td>
<td>CPU instructions are eventually <em>retired</em>.</td>
</tr>
<tr>
<td>TCP sends multiple packets in series, without waiting for the first to be acknowledged, up to the <em>window size</em>.</td>
<td>CPU issues multiple instructions in series, without waiting for the first to be retired, up to the _<a href="https://en.wikipedia.org/wiki/Reservation_station">reservation station</a> size_.</td>
</tr>
<tr>
<td>TCP packets that are &quot;in flight&quot; all make progress towards their destination at the same time.</td>
<td>CPU instructions that are in flight all make progress towards completion at the same time in a <a href="https://en.wikipedia.org/wiki/Instruction_pipelining">pipelined architecture</a>.</td>
</tr>
<tr>
<td>TCP incurs <em>packet loss</em> when a packet reaches an overloaded router. The main consequence of a packet loss is more latency between initial transmission and ultimate acknowledgement. (There are also a lot of complex state transitions.)</td>
<td>CPU incurs <em>cache misses</em> when instructions refer to memory addresses that are not cached. The main consequence of a cache miss is more latency between the initial issue of an instruction and its ultimate retirement.</td>
</tr>
<tr>
<td>The impact of a packet loss depends on the workload. Losing certain packets can cripple performance, for example a control packet like a TCP SYN or a HTTP GET, while certain other packets won&#39;t have a noticable impact at all, like losing the 900th packet in an FTP transfer. The key is whether TCP can &quot;keep the pipe full&quot; with other data while it waits to recover the lost packet.</td>
<td>The impact of a cache miss depends on the workload. Certain cache misses can cripple performance, for example when fetching the next instruction to execute or chasing a long chain of pointer-dereferences, while certain cache misses won&#39;t have a noticable impact at all, like a long series of pipelined memory accesses that all go out to RAM in parallel.</td>
</tr>
<tr>
<td>TCP can use Selective ACK to work-around hazards like packet loss and continue sending new packets beyond the slow one without waiting for it to be recovered and ACKed first.</td>
<td>CPU can use <a href="https://en.wikipedia.org/wiki/Out-of-order_execution">out-of-order execution</a> to work-around hazards like cache misses and continue executing new instructions beyond the slow one without waiting for it to be completed and retired first.</td>
</tr>
<tr>
<td>TCP can run multiple <em>connections</em> on the same link. This does not directly increase bandwidth, because they are sharing the same network resources, but it does improve robustness. If one connection is blocked by a hazard, such as a packet loss, the other can still make progress and so the link is less likely to become idle (which would waste bandwidth.)</td>
<td>CPU can run multiple <em>hyperthreads</em> on the same core. This does not directly increase performance, because they are sharing the same computing resources, but it does improve robustness. If one hyperthread is blocked by a hazard, such as a cache miss, the other can still make progress and so the core is less likely to become idle (which would waste execution cycles.)</td>
</tr>
</tbody>
</table>
<p>What do you think?</p>
<p>Have an idea for good analogs of branch prediction and dispatching instructions across multiple execution units?</p>

    </div>
  </div>
</div>
<div class="section">
  <div class="container">
          <div id="comments_container"></div>
          <div id="loadmore_container" class="has-text-centered"></div>
  </div>
</div>
          </div>
          <div class="column">
            <div class="section">
<div class="">
Hello, welcome to my blog
Here we have fun
</div>
            </div>
          </div>
  </div>
      </div>

      <script src="/assets/prism.js"></script>
      <script src="/assets/main.js"></script>
  </body>
</html>
